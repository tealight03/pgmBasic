<html>
    <title>프로그래밍 기초 2주차 과제(1)</title>
    <head></head>
    <body>
        <ul>
            <li><b>*On-premise와 Off-premise*</b>
                <p>
                    On-premise는 모든 하드웨어, 소프트웨어 및 네트워크 인프라가 내부적으로 구축되어
                    <br>기업이나 조직이 자체적으로 데이터 센터나 서버를 보유하고 운영하는 방식을 의미한다. 
                    <br>조직이 데이터 및 시스템에 직접 접근하고 제어할 수 있으며, 보안과 규정 준수에 대한 높은 수준의 통제도 가능하지만
                    <br>초기 비용과 유지 보수 비용이 상대적으로 높고, 확장성과 유연성이 제한된다는 단점 또한 존재한다. 
                    <br>Off-premise는 클라우드 서비스 기업의 IDC, 서버를 인터넷을 통해 필요한 리소스에 접근하여 IT 인프라를 구축하고 운영하는 방식이다. 
                    <br>초기 비용을 절감할 수 있고, On-premise에 비해 확장성과 유연성이 높고, 클라우드 서비스 기업이
                    <br>본 기업 대신 전반적인 관리와 유지 보수를 담당하여 상대적으로 부담이 덜하지만 데이터의 보안과 관리에 대해
                    <br>직접적으로 관리할 수 없으므로 네트워크 연결에 따른 성능에 영향을 받을 수도 있다. 
                </p>
            </li>
            <hr>
            <li>
                <b>*IDC*</b>
                <p>
                    "Internet Data Center"의 약어로, 기업 혹은 조직이 많은 양의 데이터를 처리하거나 저장하기 위해 사용하는
                    <br>대규모 컴퓨터 시스템, 네트워크 장비 및 저장소 시설로 구성된 아주 중요한 인프라이다.  
                    <br>고성능 서버, 스토리지 시스템, 네트워크 장비, 전원 관리 시스템, 냉각 시스템, 
                    <br>데이터의 기밀성과 무결성을 보호하기 위한보안 시스템 등으로 구성되어 있고,
                    <br>안정적인 전원 공급과 냉각 시스템을 유지하여 서버와 장비가 안정적으로 작동할 수 있도록 관리한다.
                    <br>근래에 들어서는 클라우드 컴퓨팅 서비스 제공업체가 IDC를 활용하여 기업들에게 
                    <br>인프라와 서비스를 제공하는 경우도 많아지는 등 클라우드 기업들에게 유연성, 확장성 및 비용 절감의 이점을 제공하기도 한다.
                </p>
            </li>
            <hr>
            <li>
                <b>*IaaS*</b>
                <p>
                    "Infrastructure as a Service"의 약어로, 클라우드 컴퓨팅 서비스 모델 중 하나이다.
                    <br>IaaS는 가상화된 서버, 네트워크, 스토리지 및 기타 기본 인프라 리소스를 제공하여 필요한 컴퓨팅 리소스를 확보하고 관리할 수 있도록 해주는데,
                    <br>사용자는 제공된 리소스를 필요에 확장하거나 축소하여 사용할 수 있다. 사용자는 기업 내에서 물리적인 서버를 구매하고 설치하는 대신 
                    <br>클라우드 환경에서 필요한 인프라를 사용하여 초기 투자 비용을 줄일 수 있고, 필요에 따라 추가 리소스를 신속하게 배포하거나 이전할 수 있다. 
                    <br>웹 애플리케이션 호스팅, 데이터 백업 및 복원, 개발 및 테스트 환경 제공 등에 사용된다. 
                </p>
            </li>
            <hr>
            <li>
                <b>*PaaS*</b>
                <p>
                    "Platform as a Service"의 약어로  PaaS는 개발자가 애플리케이션을 개발, 테스트, 배포 및 관리할 수 있는 플랫폼 환경을 제공한다. 
                    <br>개발자에게 필요한 개발 도구, 런타임 환경, 데이터베이스, 웹 서버, 운영체제, 네트워크 등을 제공하는 PaaS 제공 업체는 
                    <br>이러한 기능을 관리하고 유지 보수하며, 개발자는 이를 활용하여 애플리케이션을 구축하는 역할을 맡아 관리한다. 
                    <br> Heroku, Microsoft Azure의 App Service, Google Cloud의 App Engine 등의 기업이 PaaS 모델을 지원하는 대표 기업이다.
                </p>
            </li>
            <hr>
            <li>
                <b>*SaaS*</b>
                <p>
                    "Software as a Service"의 약어로, 사용자에게 애플리케이션을 인터넷을 통해 제공하는 형태로, 
                    <br>소프트웨어를 서비스로 제공하는 클라우드 컴퓨팅의 서비스 모델이다. 
                    <br>웹 브라우저를 통해 액세스할 수 있는 클라우드 기반의 소프트웨어 애플리케이션을 제공하므로
                    <br>사용자는 소프트웨어를 설치하거나 관리할 필요 없이 인터넷을 통해 애플리케이션에 접속하여 사용할 수 있다. 
                    <br>제공되는 애플리케이션을 호스팅하고 관리하는 업체에 의해 서비스가 유지되는 방식이라
                    <br>개발자가 관리해야할 부담이 많이 줄어드는 모델이다. 
                    <br>Salesforce, Google Workspace, Microsoft 365, Dropbox 등이 SaaS 모델 제공 업체에 해당한다. 
                </p>
            </li>
            <hr>
            <li>
                <b>*rm -rf와 위험성*</b>
                <p>
                    리눅스 명령어 중 하나인 rm 명령어는 데이터 "삭제" 명령어이다. 
                    <br>디렉토리를 삭제할 때는 rmdir, 파일 등을 삭제할 때는 rm 명령어를 사용한다. 
                    <br>rm명령어를 그냥 사용하면 정말로 이 파일을 삭제할 것이냐는 경고 문구가 등장하고, Y(y)를 누르면
                    <br>그제서야 삭제가 되는데, 이런 방식이 귀찮거나 이 파일이 삭제해야할 파일이 맞고, 빨리 다른 업무를 처리해야한다면
                    <br>-rf 라는 option 명령어를 덧붙여 경고 문구를 띄우지 않고 바로 삭제하도록 해버릴 수도 있다.
                    <br>어느 OS에서든 삭제는 아주 강력한 명령어지만, 특히 보안이 강력한 리눅스에서는
                    <br>한번 삭제된 데이터는 복구할 수 없기 때문에 이 명령어를 사용할 때 아주 주의해야한다. 
                    <br>그래서 실무에서는 직급별로 권한을 나누어 이런 삭제 명령어를 무단으로 사용할 수 없도록
                    <br>제재하여 데이터를 관리하는 방식을 갖추어 작업하도록 한다. 
                </p>
            </li>
            <hr>
            <li>
                <b>*grep*</b>
                <p>
                    주로 파일 내에서 특정 문자열이나 패턴을 갖는 라인을 검색할 때 사용되는 명령어로, 
                    <br>여러 가지 옵션을 덧붙여 편리하게 텍스트 검색과 필터링을 할 수 있다. 
                    <br>-i : 일반 검색(대소문자 구분 X)
                    <br>-r : 디렉토리 내부 파일을 재귀적으로 검색
                    <br>-l : 일치하는 패턴을 가진 파일 이름 출력
                    <br>-n : 일치하는 라인의 번호와 내용을 함께 출력
                    <br>이외에도 -v, -w, -E 등 몇 가지 옵션 명령어들이 더 있다.
                    <br>ex) grep "number" file.txt -> file.txt에서 number와 일치하는 모든 라인 출력
                </p>
            </li>
            <hr>
            <li>
                <b>*파일 사용자와 그룹*</b>
                <p>
                    리눅스에서는 파일, 디렉토리별로 해당 데이터의 소유자(보통 작성자) 혹은 그룹, 그외 계정이 해당 데이터에 접근하였을 때
                    <br>주어지는 권한이 구별되어 있다. 디렉토리의 경우 drwxrwxrwx 이런 방식으로 권한이 명시되어있는데
                    <br>앞의 d는 디렉토리 표기이고, 그 뒤부터 3개씩 끊어서 소유자, 그룹, 기타 계정 권한으로 구분하여 읽으면 된다. 
                    <br>디렉토리 혹은 파일의 소유자는 chown 명령어를 사용하여 변경할 수 있고, 접근 권한은 chmod 명령어로 변경할 수 있다. 
                    <br>예를 들어 test라는 디렉토리의 소유자 계정을 root에서 user1으로 변경하고 싶다면 chown user1 test 명령어로 바꿀 수 있고, 
                    <br>test 디렉토리에 접근하기 위한 권한을 기존에서 drwxr-xr-x로 변경하고 싶다면 chmod 755 명령어로 변경할 수 있다. 
                </p>
            </li>
            <hr>
            <li>
                <b>*netstat*</b>
                <p>
                    리눅스에서 네트워크 연결, 네트워크 인터페이스, 라우팅 테이블을 확인할 수 있는 명령어이다. 
                    <br>netstat라고 명령어를 치면 아래와 같이 결과물이 도출된다. 
                    <br>Proto Recv-Q Send-Q Local Address           Foreign Address         State      
                    <br>tcp        0      0 localhost:45792         localhost:42261         ESTABLISHED
                    <br>tcp        0      0 localhost:39256         localhost:42261         TIME_WAIT
                    <br>Active UNIX domain sockets (w/o servers)
                    <br>Proto RefCnt Flags       Type       State         I-Node   Path
                    <br>unix  2      [ ]         DGRAM                    17259    /var/run/chrony/chronyd.sock
                    <br>unix  2      [ ]         DGRAM                    22631    /run/user/1000/systemd/notify
                    <br>참고로 시간이 지날 수록 netstat은 점점 더 이식성이 떨어지기 때문에
                    <br>최신 운영 체제에서는 대체 수단으로 ss (Socket Statistics) 명령어를 권장한다고 한다. 
                </p>
            </li> 
            <hr>
            <li>
                <b>*ufw*</b>
                <p>
                    "Uncomplicated Firewall"의 약자로, 리눅스 시스템에서 방화벽을 설정하고 관리하기 위한 도구이다. 
                    <br>주로 네트워크 보안을 강화하기 위해 네트워크 트래픽을 제어하는데 사용되고, Ubuntu나 기타 리눅스 배포판에 
                    <br>대부분 포함되어 배포되어있고, 간단하고 쉽게 사용할 수 있도록 설계되어있다.
                    <br>sudo ufw enable 명령어로 방화벽 활성화 및 비활성화, sudo ufw status - 방화벽 상태 확인 등의 작업을 할 수 있는데
                    <br>개인적으로는 firewall-cmd --permanent --add-service=ftp 같은 firewall 명령어를 이용하거나 
                    <br>GUI 환경으로 접근해서 방화벽 규칙 추가/삭제 작업을 하는 게 좀 더 편리한 것 같다.
                </p>
            </li>
            <hr>
            <li>
                <b>*service*</b>
                <p>
                    Linux에서 service 명령어는 시스템 서비스를 관리하는 데 사용되는 유틸리티로,
                    <br>서비스의 시작, 중지, 재시작 등의 작업을 수행할 수 있다. 
                    <br>"service [service_name] [action]" 의 형태로 명령어를 작성하면 되고,
                    <br>service apache2 start - Apache 서버 동작
                    <br>service mysql restart - mysql 서비스 재시작 

                    <br>등의 형태로 명령어를 작성하여 사용하면 된다. 
                </p>
            </li>
            <hr>
            <li>
                <b>*branch*</b>
                <p>
                    깃허브의 특징 중 하나인 분산관리체계를 위한 개념 중 하나이다. 
                    <br>간단하게 생각해서 개별 작업 공간 정도로 이해하면 될 것 같다. 
                    <br>여러 명이서 작업하는 프로젝트를 진행할 때 데이터를 브랜치를 이용해서 관리하기도 하는데,
                    <br>개인별로 만든 작업물을 본인의 브랜치에 저장한 후, 최종적으로 공개할(컨펌한) 데이터를
                    <br>main 브랜치의 마지막 업데이트 데이터와 병합(merge)하는 방식으로 버전 관리를 해줄 수 있다. 
                    <br>깃허브에서 리포지토리를 새로 하나 생성하면 "main" 브랜치가 기본적으로 생성되는데,
                    <br>프로젝트 작업 시 개인 별 브랜치를 만들려면 git branch "새로운 브랜치 이름" 의 형식으로 작성하면 된다. 
                    <br>참고로 브랜치를 이동할 때는 git checkout "이동할 브랜치 이름"의 형식으로 명령어를 작성하면 된다.
                </p>
            </li>
            <hr>
            <li>
                <b>*stash*</b>
                <p>
                    Git 명령어 중 stash는 Git 저장소에서 변경 사항을 일시적으로 보관하고, 현재 작업 트리를 정리해주는 기능이다. 
                    <br>stash 현재 변경된 파일이나 staging area에 있는 파일을 일시적으로 보관해주기 때문에 다른 작업 브랜치로 전환할 때 유용하게 사용된다. 
                    <br>stash를 사용하고 싶다면 git stash save 명령어로 변경 사항을 stash에 일시적으로 보관하고 다른 작업을 수행한 후,
                    <br>git stash apply 혹은 git stash pop 명령어로 stash에서 이전 변경 사항을 불러와 작업 트리에 복원하는 방식으로 사용하면 된다. 
                    <br>git stash list로 현재 stash에 저장된 목록을 확인할 수도 있고, git stash drop으로 더 이상 필요하지 않는 stash를 버릴 수도 있다. 
                </p>
            </li>
            <hr>
            <li>
                <b>*merge*</b>
                <p>
                    서브 브랜치(ex. test, dev ...)에 저장해둔 작업물을 main 브랜치의 결과물과 병합하여 
                    <br>버전 관리하는 방법을 말한다.
                </p>
            </li>
            <hr>
            <li>
                <b>*conflict*</b>
                <p>
                    서로 다른 브랜치나 커밋에서 같은 파일의 같은 부분을 동시에 수정하여 병합(merge) 작업을 수행할 때 발생하는 상황을 말한다. 
                    <br>충돌은 두 개의 브랜치에서 동일한 파일의 동일한 줄을 수정한 경우 등 브랜치나 커밋 사이에 동일한 파일의 동일한 부분에 대해 
                    <br>상충하는 수정 사항이 있기 때문에 발생하는데, 이러한 충돌은 Git이 자동으로 병합할 수 없기 때문에 개발자가 직접 해결해줘야 한다. 
                    <br>마커 표시를 통해 충돌이 발생한 부분을 확인하고, 충돌이 발생하지 않도록 파일(혹은 데이터)을 수정해 
                    <br>충돌이 해결된 파일을 커밋하면 해결해줄 수 있다. 이런 문제를 잘못 해결하면 잘못된 코드끼리 꼬일 수도 있기 때문에 잘 해결해야 한다.
                </p>
            </li>
        </ul>
    </body>
</html>