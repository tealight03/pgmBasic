<html>
    <title>프로그래밍 기초 3주차 과제(1)</title>
    <head></head>
    <body>
        <ul>
            <li>
                <b>GO 언어</b> <!--C에서 파생됐다고 들었는데.. 일단 겁내 빠르다는 언어. 그리고 마스코트가 귀여움!-->
                <p>
                    Go는 2009년에 구글에서 개발한 프로그래밍 언어로, 로버트 그리즈머, 롭 파이크, 케네스 톰슨이 협력해 개발하였다.
                    <br>C, C++, Java, Python 등과 같은 기존의 프로그래밍 언어의 장점을 결합하여
                    <br>보다 간결하고 효율적인 코드를 작성할 수 있다. 또한 멀티스레딩을 지원하여 병렬 처리가 가능하며, 
                    <br>가비지 컬렉션(Garbage Collecion)을 지원하여 메모리 관리가 간편하다는 장점도 겸비하고 있다. 
                    <br>웹 개발, 네트워크 프로그래밍, 클라우드 컴퓨팅 등 다양한 분야에서 사용되고 있다. 
                    <br>참고로 C++의 복잡한 면에 불편함을 느껴서 새롭게 GO라는 언어를 만들었고, 새로운 패키지에 넣을 데이터는 세 사람이 합의해야 결정된다고 한다.
                    <br>Go 언어 사용자들을 고퍼(Gopher)라고 부르며, 고퍼들을 위한 연례행사인 고퍼콘(Gophercon)이 세계 각국에서 매년 열리고 있다고 한다. 
                </p>
            </li>
            <hr>
            <li>
                <b>C언어 헤더 파일</b>
                <p>
                    C언어의 헤더 파일은 기존에 다른 C언어 개발자들이 개발을 편리하게 하기 위해 미리 만들어둔 함수나 구조체 등을 포함한 파일이다. 
                    <br>파일의 최상단에 #include <"헤더파일명"> 과 같은 형식으로 작성하여 파일에 포함된 데이터를 사용할 수 있다.
                    <br>대표적인 헤더 파일로 stdio.h, stdlib.h, string.h, math.h 등이 있는데, 이 헤더 파일을 include 하여 가져오게 되면
                    <br>현재 내가 작업 중인 파일에서 그 헤더파일에 포함된 함수, 구조체 등을 가져다 사용할 수 있다. 
                    <br>또한 기존에 공식적으로 발표된 헤더파일들뿐만 아니라 내가 필요하다면 직접 필요한 구조체나 함수가 포함된
                    <br>헤더파일을 새로 생성해 include해서 사용할 수도 있다. 예를 들어 stack을 구현하기 위한 몇 가지 함수가 포함된 헤더파일을 만들어
                    <br>그때 그때 가져다쓰고 싶다면 createNode(), isEmpty(), isFull(),insert(), delete() 등의 함수를 파일에 작성하고,
                    <br>stack.h라는 이름으로 저장하여 헤더파일로 가져다 쓸 수 있다.
                </p>
            </li>
            <hr>
            <li>
                <b>포인터(*)와 참조(&)의 차이</b>
                <p>
                    우선 포인터는 C언어에서 처음 등장하는 개념이다. 포인터라는 이름처럼 데이터가 저장된 주소를 '가리키는' 개념이다. 
                    <br>포인터의 크기는 일정하고, primitive type별로 자신에게 맞는 포인터를 사용할 수 있다. 
                    <br>예를 들어, int형 포인터로 int형 데이터가 저장된 위치를 가리키고 싶다면
                    <br>int a = 10;
                    <br>int* ptr = &a; // *(애스터리스크)는 포인터를 상징, &은 주소를 가져오도록 하는 주소연산자이다
                    <br>과 같은 방법으로 가리킬 수 있다. 또한,
                    <br>int a = 10;
                    <br>int* ptr = &a; 
                    <br>printf("%d", *ptr); // 포인터 변수 앞에 *를 붙이면 포인터가 가리키는 위치의 데이터를 가져온다
                    <br>과 같은 방법으로 포인터가 가리키고 있는 위치에 저장된 데이터를 출력할 수도 있다.
                    <br>사람들이 많이 헷갈려하는 개념 중 하나에 속하는 포인터이니 이런 부분돋 명확하게 이해를 해야
                    <br>나중에 자료구조나 알고리즘을 공부할 때 걸림돌 없이 쭉쭉 공부해 나갈 수 있다. 
                    <br>Java언어를 배우면 포인터가 아니라 참조값으로 데이터를 가리킨다는 것을 배우게 되는데,
                    <br>실제 자바에서는 포인터라는 개념 자체가 없고, 참조, reference값으로 데이터를 가리킨다. 
                    <br>참조값은 데이터가 저장된 위치를 가리키는 것이 아니라 데이터, 그 객체(Object) 자체를 가리킨다. 
                    <br>자바에서 사용하는 객체들은 참조값을 이용해 자신이 가리키는 객체를 버리고 다른 객체를 가리킬 수도,
                    <br>한 객체를 다른 여러 객체들이 가리킬 수도 있다. 
                </p>
            </li>
            <hr>
            <li>
                <b>함수 포인터와 람다(익명) 함수</b>
                <p>
                    함수 포인터는 이전에 변수 포인터로 변수를 가리키듯이, 함수를 가리키는 포인터를 의미한다. 
                    <br>함수가 정의되면 memory의 function section에 저장되는데, 
                    <br>함수가 저장된 위치를 가리키도록 하는 함수 포인터 변수를 생성해 함수를 가리킬 수도 있다. 
                    <br>ex)
                    <br>int add(int x, int y){
                    <br>    return x+y;
                    <br>}
                    <br>int (*fptr)(int, int) = add;
                    <br>int sum = p(10, 20);
                    <br>printf("sum = %d\n", sum);
                    <br>람다 함수또한 함수를 가리키는 함수 포인터와 개념이 비슷한데, 
                    <br>함수 포인터는 함수 전체가 저장된 위치를 기억해 그 함수를 실행하는 것이라면
                    <br>람다 함수는 익명의 함수를 만들어 바디만 기억해 함수를 실행시키는 방식을 말한다. 
                    <br>int a[] = {1, 2, 3, 4, 5};
                    <br>for (int i : a) {
                    <br>    printf("%d\n", i);
                    <br>}
                    <br>람다 함수, 람다식은 대부분의 언어에서 지원되기 때문에 꼭 숙지하는 것이 좋다. 
                </p>
            </li>
            <hr>
            <li>
                <b>void 포인터와 malloc</b>
                <p>
                    void 포인터는 말 그대로 void(비어 있는)를 가리키는 포인터이다.
                    <br>간단하게 특정한 data type을 갖지 않는 데이터를 가리키는 포인터라고 이해하면 될 것 같다. 
                    <br>void포인터는 malloc, calloc과 같은 C언어의 동적할당 함수에서 사용되는데,
                    <br>아래의 예시 코드를 이용해 설명해보겠다. 
                    <br>int* arr = (int*)malloc(sizeof(int) * 10);
                    <br>이 코드에서 보면 malloc함수에 할당할 데이터의 데이터타입과 데이터 몇 개의 공간을 할당할지 알려주고
                    <br>그 앞에 int형 포인터로 캐스팅하여 10칸짜리 배열 arr을 동적할당한다는 것을 알 수 있다. 
                    <br>앞에 캐스팅을 해주는 이유는 malloc함수로 만들어낸 데이터가 void형으로 리턴되므로,
                    <br>이 데이터를 int포인터로 캐스팅해줘야 비로소 int형 배열 arr을 동적할당할 수 있기 때문이다. 
                    <br>같은 맥락으로 배열이 이와 같은 방식으로 만들어지기 때문에 배열의 이름에는 배열의 시작 주소가 저장되어있다는 것 또한 설명할 수 있다. 
                </p>
            </li>
            <hr>
            <li>
                <b>gcc의 컴파일 과정</b>
                <p>
                    전통 컴파일러에는 gcc, ghc, g++ 등이 있다. gcc는 c/c++을 위한 컴파일러이다.
                    <br>이 중 linux에서는 gcc 컴파일러를 이용해 아래와 같은 과정을 거쳐 컴파일을 한다.
                    <br>1. test.c 파일을 전처리기를 통해 test.i 파일로 변환(전처리 파일)
                    <br>2. test.i 파일을 컴파일러를 통해 test.s 파일로 변환(어셈블리 파일)
                    <br>3. test.s 파일을 어셈블러를 통해 test.o 파일로 변환(바이너리 파일)
                    <br>4. test.o 파일을 링커를 통해, test(.out) 파일로 변환
                    <br>윈도우의 경우 .exe파일, 리눅스는 .out 파일이 최종적으로 생성된다.
                </p>
            </li>
            <hr>
            <li>
                <b>nasm과 AT&T</b>
                <p>
                    어셈블리 언어의 어셈블러는 크게 NASM과 AT&T, 두 종류가 있다. 
                    <br>먼저 NASM은 Netwide Assembler의 약자로, AT&T 및 Intel 스타일의 어셈블리 언어를 지원하고
                    <br>컴파일러, 링커 및 디버거를 포함한 다양한 도구를 제공하는 어셈블러를 말한다. 
                    <br>Linux, FreeBSD, Solaris, Windows 및 macOS를 포함한 다양한 운영 체제에서 사용할 수 있다. 
                    <br>mov eax, 10 같은 명령어를 적었을 때 (instruction) (destination operand), (source operand) 형식으로 동작하는 것이 특징이다. 
                    <br>AT&T는 AT&T Bell Labs에서 개발한 어셈블리 언어로, 가장 일반적인 어셈블리 언어 스타일 중 하나이다. 
                    <br>Intel 스타일의 어셈블리 언어보다 읽기 쉽고 이해하기 쉽다는 장점이 있다. 
            <li>
                <b>빅 엔디안과 리틀 엔디안</b>
                <p>
                    어셈블리 언어에서 실제 데이터가 저장되는 두 가지 방식에 대한 내용이다. 
                    <br>val word 1234h 으로 val이라는 변수에 12 34를 저장했을 때,
                    <br>리틀 엔디안의 경우 실제 저장된 형태는 34 12로 저장되고,
                    <br>빅 엔디안의 경우 12 34, 우리가 작성한 형태와 똑같이 저장된다. 
                    <br>일반적으로 리틀 엔디안 방식으로 저장되는 경우가 많기 때문에 
                    <br>저장된 데이터를 불러올 때 인덱스를 헷갈리지 않도록 잘 적어야한다. 
                </p>
            </li>
            <hr>
            <li>
                <b>바이너리 코드와 보는 방법</b>
                <p>
                    바이너리 코드, 즉 이진 코드는 0과 1로 이루어진 코드를 말한다. 
                    <br>일반적인 사람이 이해하기 어렵고, 사람을 위한 언어가 아닌 CPU를 위한 언어이다. 
                    <br>사람이 이해하기 쉬운 언어는 High level language(고급 언어)로 주로 쓰는 C, Python, Java 등이 해당하고, 
                    <br>Middle level language(중급 언어)는 어셈블리 언어, Low level language(저급 언어)는 이진 코드가 해당한다.
                    <br>저급일수록 컴퓨터에게 친숙하고 바로바로 동작이 가능하고,
                    <br>고급일수록 컴퓨터에게 덜 친숙해서 조금 느리게 동작되는 경향이 있다. 
                    <br>우리가 일반적인 고급 언어를 이용해 작성한 코드를 바이너리 코드로 보려면
                    <br>gcc, ghc, g++ 등의 컴파일러를 이용해 컴파일한 결과를 통해 확인할 수 있다. 
                </p>
            </li> 
            <hr>
            <li>
                <b>함수 호출 방식(cdecl, stdcall, fastcall)</b> <!--엄.. 잘 모르겠다 찾아보자-->
                <p>
                    함수 호출 규약에 대해 알아보자.
                    <br>C언어에서 함수를 호출할 때 보통 사용하는 개념은 총 3가지가 있다. 
                    <br>첫 번째로 cdecl은 
                </p>
            </li>
        </ul>
    </body>
</html>